package com.p44.models

import org.specs2.mutable.Specification
import play.api.libs.iteratee.Iteratee
import play.api.libs.json.{Json, JsValue}
import reactivemongo.api.{Cursor}
import reactivemongo.bson.BSONDocument

import scala.concurrent.{Future, Await}

/**
 * Note there are 2 ways to insert in the test just for fun, only one is needed and the Persistable[T] way is simpler
 */
object WhaleSightingSpec extends Specification {

  //sbt > test-only com.p44.models.WhaleSightingSpec

  import com.p44.db.test.TestDbConfig._  // the test db and related data

  sequential

  implicit val reader = WhaleSighting.persistanceReader
  lazy val collection = WhaleSighting.getCollection(db)

  val breed: String = "Blue Whale"
  val count: Int = 2
  val description: String =  "Mommy whale and baby whale."
  val timestamp: Long = System.currentTimeMillis
  val comments: List[String] = List("Excellent!")
  val objNew = WhaleSightingNew(breed, count, description, timestamp, comments) // for insert using Insertable[T]
  val objWithStubbedId = WhaleSighting("101", breed, count, description, timestamp, comments)

  "WhaleSighting" should {
    "collection name" in {
      println("collection name - " + collection.fullCollectionName)
      collection.name mustEqual WhaleSighting.collectionName
      collection.name mustEqual WhaleSightingNew.collectionName
      collection.name mustEqual "whale_sighting"
    }

    "do Json" in {
      val json: JsValue = Json.toJson(objNew)
      println("do Json - json " + Json.stringify(json))
      val objFromJson = Json.fromJson[WhaleSightingNew](json).asOpt.getOrElse(WhaleSightingNew.empty)
      println("do Json - objFromJson " + objFromJson)
      objFromJson mustEqual objNew

      val jsonWithId: JsValue = Json.toJson(objWithStubbedId)
      println("do Json - jsonWithId " + Json.stringify(jsonWithId))
      val objFromJsonWithId = Json.fromJson[WhaleSighting](jsonWithId).asOpt.getOrElse(WhaleSighting.empty)
      println("do Json - objFromJsonWithId " + objFromJsonWithId)
      objFromJsonWithId mustEqual objWithStubbedId
    }

    "clear collection" in {
      Await.result(collection.remove(BSONDocument(), WhaleSighting.lastErrorDefault, false), timeout).ok mustEqual true
    }

    "insert one by Insertable[T].insertOneAsFuture " in {
      //Await.result(collection.insert(objNew), timeout).ok mustEqual true
      Await.result(WhaleSightingNew.insertOneAsFuture(db, objNew), timeout).ok mustEqual true
    }

    "find multiple as BSON" in {
      val q = WhaleSighting.findMongoIdExists
      val sort = WhaleSighting.sortTimestampDesc
      val opts = None
      val r: List[BSONDocument] = Await.result(collection.find(q).sort(sort).cursor[BSONDocument].collect[List](), timeout)
      println("find multiple as BSON r... ")
      r.foreach(x => println(BSONDocument.pretty(x)))
      r.size mustEqual 1
    }

    "find multiple" in {
      val q = WhaleSighting.findMongoIdExists
      val sort = WhaleSighting.sortTimestampDesc
      val opts = None
      val r: List[WhaleSighting] = Await.result(WhaleSighting.findMultipleByQueryWithSortAsFuture(db, q, sort, opts), timeout)
      println("find multiple r " + r)
      r.size mustEqual 1
    }

    "find one" in {
      val selector = WhaleSighting.findByTimestamp(timestamp)
      val found = Await.result(WhaleSighting.findOneByQueryAsFuture(db, selector), timeout).getOrElse(WhaleSighting.empty)
      println("find one by query  " + found)
      found mustNotEqual WhaleSighting.empty
    }

    "clear and insert one using Persistable[T].insertOneAsFuture" in {
      Await.result(collection.remove(BSONDocument(), WhaleSighting.lastErrorDefault, false), timeout).ok mustEqual true
      Await.result(WhaleSighting.insertOneAsFuture(db, objWithStubbedId), timeout).ok mustEqual true
    }

    "find one by query 2" in {
      val found = Await.result(collection.find(WhaleSighting.findMongoIdExists).one[WhaleSighting], timeout).getOrElse(WhaleSighting.empty)
      println("find one by query 2 " + found)
      found mustNotEqual WhaleSighting.empty
      found._id mustNotEqual objWithStubbedId._id // the _id should not have been inserted but generated by mongo
    }

    "find one with cursor" in {
      val q = WhaleSighting.findMongoIdExists
      val cursor: Cursor[WhaleSighting] = collection.find(q).cursor[WhaleSighting]
      cursor.enumerate().apply(Iteratee.foreach { x =>
        println("find one with cursor: " + x)
      })

      val cursor2: Cursor[WhaleSighting] = collection.find(q).cursor[WhaleSighting]
      val futureList: Future[List[WhaleSighting]] = cursor.collect[List](1)
      val arrivedList: List[WhaleSighting] = Await.result(futureList, timeout)
      arrivedList.foreach { x =>
        println("arrivedList only: " + x)
      }
      arrivedList.size mustEqual 1
    }

    "update and find" in {
      val s = "Mommy whale and super cute baby whale."
      val qByTs = WhaleSighting.findByTimestamp(timestamp)
      val modifier: BSONDocument = WhaleSighting.modifierSetDescription(s)
      Await.result(WhaleSighting.updateOneAsFuture(db, qByTs, modifier), timeout).ok mustEqual true
      val oFound: Option[WhaleSighting] = Await.result(collection.find(qByTs).one[WhaleSighting], timeout)
      println("find one by query 2 " + oFound)
      oFound mustNotEqual None
      oFound.get.description mustEqual s

      // update by mongoid
      val ss = "Mommy whale and super duper cute baby whale."
      val qById = WhaleSighting.findById(oFound.get._id)
      val modifier2: BSONDocument = WhaleSighting.modifierSetDescription(ss)
      Await.result(WhaleSighting.updateOneAsFuture(db, qById, modifier2), timeout).ok mustEqual true
      val oFound2: Option[WhaleSighting] = Await.result(collection.find(qById).one[WhaleSighting], timeout)
      println("find one by query 2 " + oFound2)
      oFound2 mustNotEqual None
      oFound2.get.description mustEqual ss

      // add a comment
      val modifier3: BSONDocument = WhaleSighting.modifierAddComment("Lucky you!")
      Await.result(WhaleSighting.updateOneAsFuture(db, qById, modifier3), timeout).ok mustEqual true
      val oFound3: Option[WhaleSighting] = Await.result(collection.find(qById).one[WhaleSighting], timeout)
      println("find one by query 3 " + oFound3)
      oFound2 mustNotEqual None
      println("added comments " + oFound2.get.comments.mkString(" "))
      oFound3.get.comments.size mustEqual 2

    }

    "remove by selector" in {
      val firstOnly = false
      val selector = WhaleSighting.findByTimestamp(timestamp)
      Await.result(collection.remove(selector, WhaleSighting.lastErrorDefault, firstOnly), timeout).ok mustEqual true
      val q = WhaleSighting.findMongoIdExists
      val sort = WhaleSighting.sortTimestampDesc
      val opts = None
      val r: List[WhaleSighting] = Await.result(WhaleSighting.findMultipleByQueryWithSortAsFuture(db, q, sort, opts), timeout)
      r.size mustEqual 0
    }

    "drop collection" in {
      Await.result(collection.drop(), timeout) mustEqual true
    }
  }

}
